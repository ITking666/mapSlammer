import sys
import cv2
import numpy as np
from scipy.spatial.transform import Rotation as R #To transform rotations in several formats (quaternions and matrix included)

"""
    This script reprojects the 3D map points generated by the ORB-SLAM2 execution to their 2D keyframes planes,
    saving in files (one for each keyframe) the 2D coordinates of each keypoint

    :param arg1: The directory where the ORB-SLAM2 output files are stored (trajectory and 3d map points)
    :param arg2: The trajectory generated by ORB-SLAM2 filename
    :param arg3: The 3D map points generated by ORB-SLAM2 filename
    :param arg4: The path in which the output files of this script will be saved
    :param arg5: The root of the filenames of each keyframe reprojection (the name of the frame and the extension will be added)
    :param arg6: The extension of the filenames 
"""


#####################################################
####  F U N C T I O N   D E C L A R A T I O N S  #### 
#####################################################

#Returns transformation matrix from translation and rotation (in quaternion)
def get_inv_mat_from_transAndQuat(tx, ty, tz, q1, q2, q3, q4):
    """
        This function takes a translation and a rotation (expressed with a quaternion) and returns the
        equivalent homogeneous 4x4 transformation matrix
    
        Code adapted from the one in: http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToMatrix/index.htm
    
        :param tx: Translation in the X axis
        :param ty: Translation in the Y axis
        :param tz: Translation in the Z axis
        :param q1: First element of the quaternion
        :param q2: Second element of the quaternion
        :param q3: Third element of the quaternion
        :param q4: Fourth element of the quaternion
    
        :type x: float
        :type y: float
        :type z: float
        :type q1: float
        :type q2: float
        :type q3: float
        :type q4: float
    
        :return: Homogeneous 4x4 transformation matrix
        :type: numpy.mat
    """

    w = float(q4)
    x = float(q1)
    y = float(q2)
    z = float(q3)
    
    #Generate transformation matrix
    sqw = w*w
    sqx = x*x
    sqy = y*y
    sqz = z*z 
    invs = 1 / (sqx + sqy + sqz + sqw) #invs (inverse square length) is only required if quaternion is not already normalised

    m00 = ( sqx - sqy - sqz + sqw)*invs#Since sqw + sqx + sqy + sqz =1/invs*invs
    m11 = (-sqx + sqy - sqz + sqw)*invs
    m22 = (-sqx - sqy + sqz + sqw)*invs
    
    tmp1 = x*y
    tmp2 = z*w
    m10 = 2.0 * (tmp1 + tmp2)*invs
    m01 = 2.0 * (tmp1 - tmp2)*invs
    tmp1 = x*z
    tmp2 = y*w
    m20 = 2.0 * (tmp1 - tmp2)*invs
    m02 = 2.0 * (tmp1 + tmp2)*invs
    tmp1 = y*z
    tmp2 = x*w
    m21 = 2.0 * (tmp1 + tmp2)*invs
    m12 = 2.0 * (tmp1 - tmp2)*invs
    
    #Transformation matrix
    transformation_mat = np.matrix([[m00, m01, m02, float(tx)],
                                    [m10, m11, m12, float(ty)], 
                                    [m20, m21, m22, float(tz)],
                                    [  0,   0,   0,        1]]) 


    #Inverse of the transformation matrix
    xx=float(tx)*m00+float(ty)*m10+float(tz)*m20
    yy=float(tx)*m01+float(ty)*m11+float(tz)*m21
    zz=float(tx)*m02+float(ty)*m12+float(tz)*m22

    #Transformation matrix
    transformation_mat = np.matrix([[m00, m10, m20, -xx],
                                    [m01, m11, m21, -yy], 
                                    [m02, m12, m22, -zz],
                                    [  0,   0,   0,   1]]) 

    return transformation_mat






#Saves reprojected keypoints in a file
def save_reprojected_keypoints(keypoints, filename):
    """
        This function writes the given list of reprojected keypoints ("keypoints" argument)
        in a name with the given name ("filename" argument)

        :param keypoints: List of the keypoints to save
        :param filename: The name of the file, including the path to it, the root, the current frame name and the extension
    """
    
    #Open file in "write" mode
    reprojected_points_file = open(filename, "w") 
    
    #Write the points
    idx=0
    for point in np.array(imagePoints):
        idx+=1
        #Correct possible dangerous deviations in reprojections (out of image dimensions)
        if point[0, 0] < 0:
            point[0, 0] = 0
        if point[0, 1] < 0:
            point[0, 1] = 0
        if point[0, 0] > 640:
            point[0, 0] = 640
        if point[0, 1] > 480:
            point[0, 1] = 480
    
        reprojected_points_file.write(str(point[0, 0].astype(int)) + " " + str(point[0, 1].astype(int)) + "\n") #Write point
    
    #Close the file
    reprojected_points_file.close()





#####################
####  S E T U P  ####
#####################

if len(sys.argv) != 7:
    print("[!] ERROR! The number of expected arguments was 7")
    print("  [!] Usage: python 1_reprojecter.py ORBSLAM2_output_directory keyFrame_filename mapPoints_filename path_to_save_outputs reprojectedKeyPoints_filename_root reprojectedKeyPoints_filename_extension")
    sys.exit()

#Parse arguments
orbSlam_output_path = sys.argv[1]
keyFrameTrajectory_filename = sys.argv[2]
mapPoints_filename = sys.argv[3]
output_path = sys.argv[4]
outputs_nameRoot = sys.argv[5]
outputs_fileExtension = sys.argv[6]

#Calibration parameters - from settings/TUM1.yaml
#TODO - read them from a given settings file
fx = 517.306408
fy = 516.469215
cx = 318.643040
cy = 255.313989

k1 = 0.262383
k2 = -0.953104
p1 = -0.005358
p2 = 0.002628
k3 = 1.163314

##Calibration parameters - from settings/TUM2.yaml
#fx = 520.908620
#fy = 521.007327
#cx = 325.141442
#cy = 249.701764
#
#k1 = 0.231222
#k2 = -0.784899
#p1 = -0.003257
#p2 = -0.000105
#k3 = 0.917205

##Calibration parameters - from sample_sourceDataset/rgb_corridor_kinect/kinect.yaml
#fx = 589.322232303107740
#fy = 589.849429472609130
#cx = 321.140896612950880
#cy = 235.563195335248370
#
#k1 = 0.108983708314500
#k2 = -0.239830795000911
#p1 = 0
#p2 = 0
#k3 = -0.001984065259398

##Calibration parameters - from sample_sourceDataset/rgb_room_logi/logi.yaml
#fx = 639.033036
#fy = 635.090554
#cx = 320.235143
#cy = 242.998153
#
#k1 = 0.013698
#k2 = -0.100692
#p1 = 0.000395
#p2 = 0.000466


points_3d = np.array([0, 0, 0])
rvec = (0, 0, 0)
tvec = (0, 0, 0)
params = np.matrix([[fx,  0, cx],
                    [ 0, fy, cy],
                    [ 0,  0,  1]]) #Camera parameters
distCoeffs = np.array([k1, k2, p1, p2, k3]) #Distorsion coefficients
#distCoeffs = np.array([k1, k2, p1, p2]) #Distorsion coefficients





###################
###################

line_count = 0

#Iterate over the keyframes, extracting map points and saving their reprojections
for line in open(orbSlam_output_path + keyFrameTrajectory_filename, "r"):
    #Parse new read line
    current_frame, x_trans, y_trans, z_trans, q1, q2, q3, q4 = line.split() 
    line_count += 1

    #Generate transformation matrix
    transformation_mat = get_inv_mat_from_transAndQuat(x_trans, y_trans, z_trans, q1, q2, q3, q4)
    print ("Transformation matrix for the frame " + str(current_frame) + " (keyframe #" + str(line_count) + "):")
    print (transformation_mat)
    print (" ")

    #Empty the points stack (in order not to reproject both the past and the current ones)
    points_3d = np.array([0, 0, 0])

    #Read the 3D points to reproject (from the 3D map previously generated with ORB-SLAM2)
    for line in open(orbSlam_output_path + mapPoints_filename, "r"):
        #Split info in frame name, point ID (useless) and 3D coordinates
        frame_name, pointID, x_3d, y_3d, z_3d = line.split() 

        if frame_name == current_frame: #If the point correspond to the actual frame
            point_4d = np.matrix([[float(x_3d), float(y_3d), float(z_3d), 1]]) #Create point (x, y, z, 1)
            transformed_point_4d = transformation_mat*np.transpose(point_4d) #Apply rotation and translation to the point (matrix*Point)

            points_3d = np.vstack([points_3d, transformed_point_4d[0:3,:].squeeze()]) #Add the new point to the stack
    #TODO - break once processed the current frame

    imagePoints, jacob = cv2.projectPoints(objectPoints=points_3d[1:], rvec=rvec, tvec=tvec, cameraMatrix=params, distCoeffs=distCoeffs)

    #Save reprojected points
    save_reprojected_keypoints(imagePoints, output_path + outputs_nameRoot + current_frame + outputs_fileExtension)

